- form = local_assigns.fetch(:form)
- project = local_assigns.fetch(:project)

.form-group
  = label_tag :merge_method_merge, class: 'label-light' do
    Merge method
  .radio
    = label_tag :project_merge_method_merge do
      = form.radio_button :merge_method, :merge, class: "js-merge-method-radio"
      %strong Merge commit
      %br
      %span.descr
        A merge commit is created for every merge, and merging is allowed as long as there are no conflicts.

  .radio
    = label_tag :project_merge_method_rebase_merge do
      = form.radio_button :merge_method, :rebase_merge, class: "js-merge-method-radio"
      %strong Merge commit with semi-linear history
      %br
      %span.descr
        A merge commit is created for every merge, but merging is only allowed if fast-forward merge is possible.
        This way you could make sure that if this merge request would build, after merging to target branch it would also build.
      %br
      %span.descr
        When fast-forward merge is not possible, the user is given the option to rebase.

  .radio
    = label_tag :project_merge_method_ff do
      = form.radio_button :merge_method, :ff, class: "js-merge-method-radio"
      %strong Fast-forward merge
      %br
      %span.descr
        No merge commits are created and all merges are fast-forwarded, which means that merging is only allowed if the branch could be fast-forwarded.
      %br
      %span.descr
        When fast-forward merge is not possible, the user is given the option to rebase.

.form-group
  = form.label :merge_requests_template, class: 'label-light' do
    Default description template for merge requests
    = link_to icon('question-circle'), help_page_path('user/project/description_templates', anchor: 'setting-a-default-template-for-issues-and-merge-requests'), target: '_blank'
  = form.text_area :merge_requests_template, class: "form-control", rows: 3
  .hint
    Description parsed with #{link_to "GitLab Flavored Markdown", help_page_path('user/markdown'), target: '_blank'}.

.form-group.reset-approvals-on-push
  .checkbox
    = label_tag :require_approvals do
      = check_box_tag :require_approvals, nil, project.approvals_before_merge > 0
      %strong Activate merge request approvals
      = link_to icon('question-circle'), help_page_path("user/project/merge_requests/merge_request_approvals"), target: '_blank'
      .descr Merge request approvals allow you to set the number of necessary approvals and predefine a list of approvers that you will need to approve every merge request in a project.

.nested-settings
  .form-group
    = form.label :approver_ids, class: 'label-light' do
      Approvers
    .input-group.input-btn-group
      = users_select_tag("project[approver_ids]", multiple: true, class: 'input-large', scope: :all, email_user: true)
      %button.btn.btn-success.js-approvers{ type: 'button', title: 'Add approver(s)', data: { for: 'project[approver_ids]' } }
        Add
    .help-block
      Add an approver suggestion for each merge request

    = form.label :approver_group_ids, class: 'label-light' do
      Approver groups
    .input-group.input-btn-group
      - skip_groups = project.approver_groups.pluck(:group_id)
      = groups_select_tag('project[approver_group_ids]', multiple: true, data: { skip_groups: skip_groups, all_available: true }, class: 'input-large')
      %button.btn.btn-success.js-approvers{ type: 'button', title: 'Add group(s)', data: { for: 'project[approver_group_ids]' } }
        Add
    .help-block
      Add a group as an approver suggestion for each merge request

    .panel.panel-default.prepend-top-10
      .panel-heading
        Approvers
        -# TODO: badge with project.approver_group_ids.count + project.approver_ids.count
      %ul.well-list.approver-list
        .load-wrapper.hidden
          = icon('spinner spin', class: 'approver-list-loader')
        - project.approvers.each do |approver|
          %li.approver.settings-flex-row
            = link_to approver.user.name, approver.user
            .pull-right
              = link_to namespace_project_approver_path(project.namespace, project, approver), data: { confirm: "Are you sure you want to remove approver #{approver.user.name}"}, class: "btn btn-remove js-approver-remove", title: 'Remove approver' do
                = icon("trash")
        - project.approver_groups.each do |approver_group|
          %li.approver-group.settings-flex-row
            .span
              %span.light
                Group:
              = link_to approver_group.group.name, approver_group.group
              %span.badge
                = approver_group.group.members.count
            .pull-right
              = link_to namespace_project_approver_group_path(project.namespace, project, approver_group), data: { confirm: "Are you sure you want to remove group #{approver_group.group.name}" }, class: "btn btn-remove js-approver-remove", title: 'Remove group' do
                = icon("trash")
        - if project.approvers.empty? && project.approver_groups.empty?
          %li There are no approvers

  .form-group
    = form.label :approvals_before_merge, class: 'label-light' do
      Approvals required
    = form.number_field :approvals_before_merge, class: "form-control", min: 0
    .help-block

  .form-group.reset-approvals-on-push
    .checkbox
      = form.label :reset_approvals_on_push do
        = form.check_box :reset_approvals_on_push
        %strong Reset approvals on push
        .descr Approvals are reset when new data is pushed to the merge request

:javascript
  new UsersSelect();
  new GroupsSelect();
