diff a/spec/requests/api/users_spec.rb b/spec/requests/api/users_spec.rb	(rejected hunks)
@@ -1,12 +1,12 @@
 require 'spec_helper'
 
-describe API::Users, api: true  do
+describe API::Users, api: true do
   include ApiHelpers
 
-  let(:user)  { create(:user) }
+  let(:user) { create(:user) }
   let(:admin) { create(:admin) }
-  let(:key)   { create(:key, user: user) }
-  let(:email)   { create(:email, user: user) }
+  let(:key) { create(:key, user: user) }
+  let(:email) { create(:email, user: user) }
   let(:omniauth_user) { create(:omniauth_user) }
   let(:ldap_user) { create(:omniauth_user, provider: 'ldapmain') }
   let(:ldap_blocked_user) { create(:omniauth_user, provider: 'ldapmain', state: 'ldap_blocked') }
@@ -827,7 +827,7 @@ describe API::Users, api: true  do
       user.save
       expect do
         delete api("/user/keys/#{key.id}", user)
-      end.to change{user.keys.count}.by(-1)
+      end.to change { user.keys.count }.by(-1)
       expect(response).to have_http_status(200)
     end
 
@@ -931,7 +931,7 @@ describe API::Users, api: true  do
       user.save
       expect do
         delete api("/user/emails/#{email.id}", user)
-      end.to change{user.emails.count}.by(-1)
+      end.to change { user.emails.count }.by(-1)
       expect(response).to have_http_status(200)
     end
 
@@ -984,7 +984,7 @@ describe API::Users, api: true  do
   end
 
   describe 'PUT /users/:id/unblock' do
-    let(:blocked_user)  { create(:user, state: 'blocked') }
+    let(:blocked_user) { create(:user, state: 'blocked') }
     before { admin }
 
     it 'unblocks existing user' do
@@ -1100,4 +1100,78 @@ describe API::Users, api: true  do
       expect(json_response['message']).to eq('404 User Not Found')
     end
   end
+
+  context "user activities", :redis do
+    it_behaves_like 'a paginated resources' do
+      let(:request) { get api("/user/activities", admin) }
+    end
+
+    context 'last activity as normal user' do
+      it 'has no permission' do
+        user.record_activity
+
+        get api("/user/activities", user)
+
+        expect(response).to have_http_status(403)
+      end
+    end
+
+    context 'last activity as admin' do
+      it 'returns the last activity' do
+        allow(Time).to receive(:now).and_return(Time.new(2000, 1, 1))
+
+        user.record_activity
+
+        get api("/user/activities", admin)
+
+        activity = json_response.last
+
+        expect(activity['username']).to eq(user.username)
+        expect(activity['last_activity_at']).to eq('2000-01-01 00:00:00')
+      end
+    end
+
+    context 'last activities paginated', :redis do
+      let(:activity) { json_response.first }
+      let(:old_date) { 2.months.ago.to_date }
+
+      before do
+        5.times do |num|
+          Timecop.freeze(old_date + num)
+
+          create(:user, username: num.to_s).record_activity
+        end
+      end
+
+      after do
+        Timecop.return
+      end
+
+      it 'returns 3 activities' do
+        get api("/user/activities?page=1&per_page=3", admin)
+
+        expect(json_response.count).to eq(3)
+      end
+
+      it 'contains the first activities' do
+        get api("/user/activities?page=1&per_page=3", admin)
+
+        expect(json_response.map { |activity| activity['username'] }).to eq(%w[0 1 2])
+      end
+
+      it 'contains the last activities' do
+        get api("/user/activities?page=2&per_page=3", admin)
+
+        expect(json_response.map { |activity| activity['username'] }).to eq(%w[3 4])
+      end
+
+      it 'contains activities created after user 3 was created' do
+        from = (old_date + 3).to_s("%Y-%m-%d")
+
+        get api("/user/activities?page=1&per_page=5&from=#{from}", admin)
+
+        expect(json_response.map { |activity| activity['username'] }).to eq(%w[3 4])
+      end
+    end
+  end
 end
