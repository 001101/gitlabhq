# frozen_string_literal: true
module API
  class MavenPackages < Grape::API
    MAVEN_ENDPOINT_REQUIREMENTS = {
      app_name: API::NO_SLASH_URL_PART_REGEX,
      app_version: API::NO_SLASH_URL_PART_REGEX,
      file_name: API::NO_SLASH_URL_PART_REGEX
    }.freeze

    MAVEN_METADATA_FILE = 'maven-metadata.xml'.freeze

    content_type :md5, 'text/plain'
    content_type :sha1, 'text/plain'
    content_type :binary, 'application/octet-stream'

    before { authenticate_non_get! }

    helpers do
      def extract_format(file_name)
        name, _, format = file_name.rpartition('.')

        if %w(md5 sha1).include?(format)
          [name, format]
        else
          [file_name, nil]
        end
      end

      def valid_metadata_xml?(xml)
        version = Nokogiri::XML(xml).css('metadata:root > version').text

        # Skip handling top level maven-metadata.xml (one without the version) for now.
        # Also make sure version in the metadata file is equal to one in the URL
        version.present? && version == params[:app_version]
      end
    end

    params do
      requires :id, type: String, desc: 'The ID of a project'
    end
    resource :projects, requirements: API::PROJECT_ENDPOINT_REQUIREMENTS do
      desc 'Download the maven package file' do
        detail 'This feature was introduced in GitLab 11.3'
      end
      params do
        requires :app_group, type: String, desc: 'Package group id'
        requires :app_name, type: String, desc: 'Package artifact id'
        requires :app_version, type: String, desc: 'Package version'
        requires :file_name, type: String, desc: 'Package file name'
      end
      get ':id/packages/maven/*app_group/:app_name/:app_version/:file_name', requirements: MAVEN_ENDPOINT_REQUIREMENTS do
        unauthorized! unless can?(current_user, :read_package, user_project)

        file_name, format = extract_format(params[:file_name])

        metadata = ::Packages::MavenMetadatum.find_by!(app_group: params[:app_group],
                                                       app_name: params[:app_name],
                                                       app_version: params[:app_version])

        package_file = metadata.package.package_files.recent.find_by!(file_name: file_name)

        case format
        when 'md5'
          package_file.file_md5
        when 'sha1'
          package_file.file_sha1
        when nil
          present_carrierwave_file!(package_file.file)
        end
      end

      desc 'Upload the maven package file' do
        detail 'This feature was introduced in GitLab 11.3'
      end
      params do
        requires :app_group, type: String, desc: 'Package group id'
        requires :app_name, type: String, desc: 'Package artifact id'
        requires :app_version, type: String, desc: 'Package version'
        requires :file_name, type: String, desc: 'Package file name'
      end
      put ':id/packages/maven/*app_group/:app_name/:app_version/:file_name/authorize', requirements: MAVEN_ENDPOINT_REQUIREMENTS do
        not_allowed! unless Gitlab.config.packages.enabled
        unauthorized! unless can?(current_user, :admin_package, user_project)

        require_gitlab_workhorse!
        Gitlab::Workhorse.verify_api_request!(headers)

        status 200
        content_type Gitlab::Workhorse::INTERNAL_API_CONTENT_TYPE
        ::Packages::PackageFileUploader.workhorse_authorize(has_length: true)
      end

      desc 'Upload the maven package file' do
        detail 'This feature was introduced in GitLab 11.3'
      end
      params do
        requires :app_group, type: String, desc: 'Package group id'
        requires :app_name, type: String, desc: 'Package artifact id'
        requires :app_version, type: String, desc: 'Package version'
        requires :file_name, type: String, desc: 'Package file name'
        optional 'file.path', type: String, desc: %q(path to locally stored body (generated by Workhorse))
        optional 'file.name', type: String, desc: %q(real filename as send in Content-Disposition (generated by Workhorse))
        optional 'file.type', type: String, desc: %q(real content type as send in Content-Type (generated by Workhorse))
        optional 'file.size', type: Integer, desc: %q(real size of file (generated by Workhorse))
        optional 'file.sha256', type: String, desc: %q(sha256 checksum of the file (generated by Workhorse))
      end
      put ':id/packages/maven/*app_group/:app_name/:app_version/:file_name', requirements: MAVEN_ENDPOINT_REQUIREMENTS do
        not_allowed! unless Gitlab.config.packages.enabled
        unauthorized! unless can?(current_user, :admin_package, user_project)

        require_gitlab_workhorse!

        file_name, format = extract_format(params[:file_name])

        uploaded_file = UploadedFile.from_params(params, :file, ::Packages::PackageFileUploader.workhorse_local_upload_path)
        bad_request!('Missing package file!') unless uploaded_file

        metadata = ::Packages::MavenMetadatum.find_by(app_group: params[:app_group],
                                                      app_name: params[:app_name],
                                                      app_version: params[:app_version])

        # TODO: Refactor. We don't need to read file for every request, only metadata and md5/sha1
        string_file = File.read(uploaded_file)

        unless metadata
          if file_name == MAVEN_METADATA_FILE
            return unless valid_metadata_xml?(string_file)
          end

          # There is no metadata for this upload. We need to create a package
          # record and corresponding maven metadata record
          metadata = Packages::CreateMavenPackageService.new(user_project, current_user, params).execute
        end

        if format
          # Maven tries to create a md5 and sha1 files for each package file.
          # Instead, we update existing package file record with such data.
          package_file = metadata.package.package_files.recent.find_by!(file_name: file_name)

          case format
          when 'md5'
            package_file.file_md5 = string_file
          when 'sha1'
            package_file.file_sha1 = string_file
          end
        else
          # TODO: If maven-metadata.xml file is present for this package, we
          # need to update it instead of creating a new one
          package_file = metadata.package.package_files.new
          package_file.file_name = file_name
          package_file.file_type = file_name.rpartition('.').last

          # Convert string into CarrierWave compatible StringIO object
          package_file.file = uploaded_file
        end

        package_file.save!
      end
    end
  end
end
