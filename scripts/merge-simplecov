#!/usr/bin/env ruby
begin
  load File.expand_path('../spring', __FILE__)
rescue LoadError => e
  raise unless e.message.include?('spring')
end

require 'simplecov'

def read(file)
  return unless File.exist?(file)
  data = File.read(file)
  return if data.nil? || data.length < 2
  data
end

def load(file)
  begin
    JSON.parse(read(file))
  rescue
    {}
  end
end

def files
  Dir.glob(File.join(SimpleCov.coverage_path, '*', '.resultset.json'))
end

def resultsfiles
  files.map { |file| load(file) }
end

def resultsets
  resultsfiles.reduce({}, :merge)
end

def all_results
  results = []
  resultsets.each do |command_name, data|
    result = SimpleCov::Result.from_hash(command_name => data)
    # Only add result if the timeout is above the configured threshold
    if (Time.now - result.created_at) < SimpleCov.merge_timeout
      results << result
    end
  end
  results
end

def merge_resultset(a1, a2)
  return a1 || [] unless a2
  return a2 || [] unless a1

  new_array = a1.dup
  a2.each_with_index do |element, i|
    if element.nil? && new_array[i].nil?
      new_array[i] = nil
    elsif element.nil? && new_array[i] == 0 || element == 0 && new_array[i].nil?
      new_array[i] = nil
    else
      local_value = element || 0
      other_value = new_array[i] || 0
      new_array[i] = local_value + other_value
    end
  end
  new_array
end

def merge_hashes(h1, h2)
  new_resultset = {}
  (h1.keys + h2.keys).each do |filename|
    new_resultset[filename] = []
  end

  new_resultset.each_key do |filename|
    new_resultset[filename] = merge_resultset(h1[filename], h2[filename])
  end
  new_resultset
end

def merged_result
  merged = {}
  results = all_results
  results.each do |result|
    merged = merge_hashes(result.original_result, merged)
  end
  result = SimpleCov::Result.new(merged)
  # Specify the command name
  result.command_name = results.map(&:command_name).sort.join(", ")
  result
end

# Ignore CI environment
ENV['CI'] = nil
ENV['CI_BUILD_NAME'] = nil

require_relative '../spec/simplecov_env'

merged_result.format!
